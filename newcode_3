import keras
from keras import layers
from keras.models import Sequential, Model
from tensorflow.python.keras.models import Input
from keras.layers import Dense, Dropout, Flatten, concatenate
from keras.layers import Conv2D, MaxPooling2D
from tensorflow.keras.layers import BatchNormalization
from keras.preprocessing.image import ImageDataGenerator

import sys
import os
import scipy as sp
import matplotlib.pyplot as plt

from sklearn import metrics
from sklearn.model_selection import train_test_split

import numpy as np
import pandas as pd
import seaborn as sns
from math import log
from PIL import Image

path_root = "D:\Projects\ISAA\malimg_paper_dataset_imgs"

batches = ImageDataGenerator().flow_from_directory(directory = path_root, target_size=(64,64), batch_size = 10000)
imgs, labels = next(batches)

X_train, X_test, y_train, y_test = train_test_split(imgs/255, labels, test_size= 0.3)

root = "D:\Projects\ISAA\Malware Images"

def convertAndSave(arr, name):

    print("Processing " + name)
    if arr.shape[1] != 16: #If not hexadecimal
        assert (False)
    b = int((arr.shape[0]*16)**(0.5))
    b = 2**(int(log(b)/log(2))+1)
    a = int(arr.shape[0]*16/b)
    arr = arr[:a*b//16,:]
    arr = np.reshape(arr,(a,b))
    im = Image.fromarray(np.uint8(arr))
    im.save(root + '\\' + name + '.png', "PNG")
    return im


def malware_model():
    img_size =64
    left_inputs = Input(shape=(img_size, img_size, 3))
    filters=32
    x = left_inputs
    for i in range(3):
        x = Conv2D(filters,3,activation='relu', padding='same')(x)
        x = Dropout(0.3)(x)
        x= MaxPooling2D()(x) 
        filters*=2
        right_inputs=Input(shape=(img_size, img_size, 3)) 
        y=right_inputs
        filters=32
    for i in range(3):
        y = Conv2D(filters, 3, activation='relu',padding='same', dilation_rate=2)(y)
        y = Dropout(0.3)(y)
        y = MaxPooling2D()(y)
        filters*=2
    y=concatenate([x,y])
    y = Flatten()(y)
    y=Dropout(0.3)(y)
    op = Dense(25, activation='softmax')(y)
    model = Model(inputs=[left_inputs, right_inputs], outputs=op)
    model.compile(loss='categorical_crossentropy', optimizer = 'adam', metrics=['accuracy'])
    model.add(layers.BatchNormalization())
    return model


def malware_cnn_model():

    Malware_model = Sequential () 
    Malware_model.add(Conv2D(30, kernel_size=(3, 3), activation= 'relu', input_shape=(64,64,3)))
    Malware_model.add(MaxPooling2D(pool_size=(2, 2)))
    Malware_model.add(Conv2D(15, (3, 3), activation='relu'))
    Malware_model.add(MaxPooling2D(pool_size=(2, 2)))
    Malware_model.add(Dropout(0.25))
    Malware_model.add(Flatten()) 
    Malware_model.add(Dense(128, activation='relu'))
    Malware_model.add (Dropout (0.5))
    Malware_model.add(Dense (50, activation='relu'))
    Malware_model.add(Dense (25, activation='softmax')) 
    Malware_model.compile(loss='categorical_crossentropy', optimizer = 'adam', metrics=['accuracy'])
    return Malware_model

def make_generator_model():
    model=keras.Sequential()
    model.add(layers.Dense (8*8*512, use_bias=False, input_shape=(64*64*3,))) 
    model.add(layers.BatchNormalization())
    model.add(layers.LeakyReLU())

    model.add(layers.Reshape((8, 8, 512)))
    assert model.output_shape == (None, 8, 8, 512) #Note: None is the batch size
    model.add(layers.Conv2DTranspose(256, (5, 5), strides = (1, 1), padding='same', use_bias=False)) 
    assert model.output_shape== (None, 8, 8, 256)
    model.add(layers.BatchNormalization())
    model.add(layers.LeakyReLU())

    model.add(layers.Conv2DTranspose(128, (5, 5), strides =(2, 2), padding='same', use_bias=False)) 
    assert model.output_shape== (None, 16, 16, 128) 
    model.add(layers.BatchNormalization())
    model.add(layers.LeakyReLU())

    model.add(layers.Conv2DTranspose(64, (5, 5), strides= (2, 2), padding='same', use_bias=False))
    assert model.output_shape== (None, 32, 32, 64) 
    model.add(layers.BatchNormalization())
    model.add(layers.LeakyReLU())
    
    model.add(layers.Conv2DTranspose(3, (5, 5), strides =(2, 2), padding='same', use_bias=False, activation='tanh'))
    assert model.output.shape == (None, 64, 64, 3)
    return model
    
    def confusion_matrix(confusion_matrix, class_names, figsize = (10,7), fontsize = 14):
    df_cm = pd.DataFrame(
        confusion_matrix, index=class_names, columns=class_names, 
    )
    fig = plt.figure(figsize=figsize)
    try:
        heatmap = sns.heatmap(df_cm, annot=True, fmt = "d")
    except ValueError:
        raise ValueError("Confusion matrix values must be integers.")
    heatmap.yaxis.set_ticklabels(heatmap.yaxis.get_ticklabels(), rotation=0, ha='right', fontsize=fontsize)
    heatmap.xaxis.set_ticklabels(heatmap.xaxis.get_ticklabels(), rotation=45, ha='right', fontsize=fontsize)
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

Malware_model = malware_model()
y_pred = Malware_model.predict_classes(X_test, verbose=0)
y_test2 = np.argmax(y_test, axis=1)
c_matrix = metrics.confusion_matrix(y_test2, y_pred)
class_names= batches.class_indices.keys()
confusion_matrix(c_matrix, class_names, figsize = (20,7), fontsize=14)
